{*******************************************************************************
Function GetAnimation: Integer;
By: lordsaturn
Description: Gets character animation
*******************************************************************************}
function GetAnimation: Integer;
var
  MyPlayer : Integer;
begin
  MyPlayer := SmartGetFieldObject(0, hook_static_MyPlayer);
  Result := SmartGetFieldInt(MyPlayer, hook_character_Animation);
  SmartFreeObject(MyPlayer);
end;

{*******************************************************************************
function IsIdle: Boolean;
By: lordsaturn
Description: Returns true if the your player is idle. (no movement or animation)
*******************************************************************************}
function IsIdle: Boolean;
begin
  Result := (GetAnimation = -1) and (GetSpeed = 0);
end;

{*******************************************************************************
function CharacterMoving: Boolean;
By: lordsaturn
Description: Returns true if the your player is moving
*******************************************************************************}
function CharacterMoving: Boolean;
begin
  Result := (GetSpeed > 0);
end;

{*******************************************************************************
function CharacterAnimating: Boolean;
By: lordsaturn
Description: Returns true if the your player is moving
*******************************************************************************}
function CharacterAnimating: Boolean;
begin
  Result := (GetAnimation > -1);
end;

{*******************************************************************************
function WaitForAnimation(timeout: integer): boolean;
By: Drags111
Description: Waits until your character animates, or the timeout is reached.
*******************************************************************************}
function WaitForAnimation(timeout: integer): boolean;
var
  t: integer;
begin
  Result := false;
  MarkTime(t);
  while GetAnimation = -1 do
  begin
    if(TimeFromMark(t) >= timeout)then
      Exit;
    wait(50);
  end;
  Result := true;
end;

{*******************************************************************************
function _GetNPCActionArray(NPCDef: integer): TStringArray;
By: Drags111
Description: Gets the Action (String) Array according to the NPC Def.
             Used in GetNPC functions
*******************************************************************************}
function _GetNPCActionArray(NPCDef: integer): TStringArray;
var
  i, c, bytes: integer;
begin
  SetLength(Result, 11);
  c := 0;
  for i := 0 to 10 do
  begin
    bytes := SmartGetFieldArrayObject(NPCDef, hook_npcdef_GetActions, i);
    if(bytes > 0)then
    begin
      Result[c] := GetJavaString(bytes, 255);
      inc(c);
    end;
    SmartFreeObject(bytes);
  end;
  SetLength(Result, c);
end;

{*******************************************************************************
Function SortNPCs(NPCs:array of TNPC):array of TNPC;
By: Widget edited by lordsaturn
Description: Sorts NPCs by distance from you.
*******************************************************************************}
function SortNPCs(NPCs:array of TNPC): TNPCArray;
var
  i,i2, L: integer;
  tpa: TPointArray;
begin
  L := GetArrayLength(NPCs);
  if L < 1 then Exit;
  SetArrayLength(TPA, L);
  SetArrayLength(Result, L);
  for i := 0 to L-1 do
    TPA[i] := NPCs[i].Tile;
  SortTPAFrom(TPA, GetMyPos);
  for i := 0 to L-1 do
    for i2 := 0 to L-1 do
      if (TPA[i].x=NPCs[i2].Tile.x) and (TPA[i].y=NPCs[i2].Tile.y) then
        Result[i] := NPCs[i2];
end;

{*******************************************************************************
function GetNPCs: TNPCArray;
By: Drags111
Description: Stores all the loaded NPCs into an array of TNPC;
*******************************************************************************}
function GetNPCs:array of TNPC;
var
  i, c, NumNPCs, Index, TheNPC, TheNPCDef, TheBytes, TheNPCNode: integer;
begin
  NumNPCs := SmartGetFieldInt(0,hook_static_NPCCount);
  if (NumNPCs < 1) then Exit;
  SetArrayLength(Result,NumNPCs);
  for i := 0 to (NumNPCs-1) do
  try
    Index := SmartGetFieldArrayInt(0, hook_static_NPCIndexArray, i);
    TheNPCNode := SmartGetFieldArrayObject(0, hook_static_NPCNodes, i);
    TheNPC := SmartGetFieldObject(TheNPCNode, hook_npcnode_GetNPC);
    TheNPCDef := SmartGetFieldObject(TheNPC, hook_npc_NPCDef);
    TheBytes := SmartGetFieldObject(TheNPCDef, hook_npcdef_GetName);

    if(lowercase(trim(GetJavaString(TheBytes, 255))) = 'null')then
      continue;
    Result[c].Index := Index;
    Result[c].ID := SmartGetFieldInt(TheNPCDef, hook_npcdef_GetID);
    Result[c].Name := GetJavaString(TheBytes, 255);
    Result[c].Actions := _GetNPCActionArray(TheNPCDef);
    Result[c].Tile.X := (SmartGetFieldInt(0, hook_static_BaseX) + (SmartGetFieldInt(TheNPC, hook_animable_PixelX) / 512));
    Result[c].Tile.Y := (SmartGetFieldInt(0, hook_static_BaseY) + (SmartGetFieldInt(TheNPC, hook_animable_PixelY) / 512));
    Result[c].Pixel.X := SmartGetFieldInt(TheNPC, hook_animable_PixelX) mod 512;
    Result[c].Pixel.Y := SmartGetFieldInt(TheNPC, hook_animable_PixelY) mod 512;
    Result[c].Moving := (SmartGetFieldInt(TheNPC, hook_character_Motion)>0);
    Result[c].Animation := SmartGetFieldInt(TheNPC, hook_character_Animation);
    Result[c].Height := iabs(SmartGetFieldInt(TheNPC, hook_character_GetHeight));
    Result[c].HPRatio := SmartGetFieldInt(TheNPC, hook_character_HPRatio) * 100 / $FF;
    Result[c].Fighting := (SmartGetFieldInt(TheNPC, hook_character_LoopCycleStatus) >
                              SmartGetFieldInt(0, hook_static_LoopCycle));
    Result[c].Orientation := Round(FixD(180 + (SmartGetFieldInt(TheNPC, hook_character_Orientation)* 45) / 2048));
    Result[c].Level := SmartGetFieldInt(TheNPCDef, hook_npcdef_GetLevel);
    Result[c].Interacting := SmartGetFieldInt(TheNPC, hook_character_GetInteracting);
    Inc(c);

  finally
    SmartFreeObject(TheNPCNode);
    SmartFreeObject(TheNPC);
    SmartFreeObject(TheNPCDef);
    SmartFreeObject(TheBytes);
  end;
  SetLength(Result, c);
end;

{*******************************************************************************
function GetNPCsBy(TheVar: Variant): array of TNPC;
By: Widget, lordsaturn, Narcle and Nava2
Description: Returns all the currently loaded NPCs using TheVar, which will
             take either a string or an Integer. The String is a part of the NPC
             name, and an Integer is the NPCType (ID).
*******************************************************************************}
function GetNPCsBy(TheVar: Variant): TNPCArray;
var
  vType, i, resCounter, Hi: Integer;
  NPCs: TNPCArray;
  b: boolean;
begin
  {
    Initialize the result array, setup for looping.
  }
  NPCs := SortNPCs(GetNPCs);
  SetLength(Result, Length(NPCs));
  vType := VarType(TheVar);
  if (vType = varString) then
    TheVar := LowerCase(Trim(TheVar));
  Hi := High(NPCs);
  for i := Hi downto 0 do
  begin
    case vType of
      varInteger: B := NPCs[i].ID = TheVar;
      varString: B := (Pos(TheVar, LowerCase(Trim(NPCs[i].Name))) > 0);
      else Exit;
    end;
    if not B then
      Continue;
    Result[resCounter] := NPCs[i];
    inc(resCounter);
  end;

  SetLength(Result, resCounter);
end;

{*******************************************************************************
function GetNPC(theVar: Variant):TNPC;
By: Drags111
Description: Returns the npc by the varient (name or ID).
*******************************************************************************}
function GetNPC(theVar: Variant):TNPC;
var
  NPCs: TNPCArray;
  i, vType, Hi: Integer;
  B: Boolean;
begin
  Result := NULL_NPC;
  vType := VarType(TheVar);
  if (vType = varString) then
    TheVar := LowerCase(TheVar);
  NPCs := SortNPCS(GetNPCs);
  Hi := High(NPCs);
  for i := Hi downto 0 do
  begin
    case (vType) of
      varInteger: B := NPCs[i].ID = TheVar;
      varString: B := (Pos(TheVar, LowerCase(NPCs[i].Name)) > 0);
      else Continue;
    end;
    if (B) then
    begin
      Result := NPCs[i];
      Exit;
    end;
  end;
end;

{*******************************************************************************
function GetNPCsAt(T: TTile): TNPCArray;
By:
Description: Returns an array of the NPCs at the given tile
*******************************************************************************}
function GetNPCsAt(T: TTile): TNPCArray;
var
  i, h, c: Integer;
  Index, TheNPCNode, TheNPC, TheNPCDef, TheBytes: Integer;
  tmp_tile : TTile;
begin
  h := SmartGetFieldInt(0, hook_static_NPCCount);
  SetLength(Result, h);
  Dec(h);
  for i := 0 to h do
  try
    Index := SmartGetFieldArrayInt(0, hook_static_NPCIndexArray, i);
    TheNPCNode := SmartGetFieldArrayObject(0, hook_static_NPCNodes, i);
    TheNPC := SmartGetFieldObject(TheNPCNode, hook_npcnode_GetNPC);
    tmp_tile := Tile(
		   SmartGetFieldInt(0,hook_static_BaseX) +
			SmartGetFieldInt(TheNPC, hook_animable_PixelX) / 512,
		   SmartGetFieldInt(0,hook_static_BaseY) +
			SmartGetFieldInt(TheNPC, hook_animable_PixelY) / 512);

    if (tmp_tile = t) then
    begin
      TheNPCDef := SmartGetFieldObject(TheNPC, hook_npc_NPCDef);
      TheBytes := SmartGetFieldObject(TheNPCDef, hook_npcdef_GetName);
      Result[c].Index := Index;
      Result[c].ID := SmartGetFieldInt(TheNPCDef, hook_npcdef_GetID);
      Result[c].Name := GetJavaString(TheBytes, 255);
      Result[c].Actions := _GetNPCActionArray(TheNPCDef);
      Result[c].Tile.X := (SmartGetFieldInt(0, hook_static_BaseX) + (SmartGetFieldInt(TheNPC, hook_animable_PixelX) / 512));
      Result[c].Tile.Y := (SmartGetFieldInt(0, hook_static_BaseY) + (SmartGetFieldInt(TheNPC, hook_animable_PixelY) / 512));
      Result[c].Moving := (SmartGetFieldInt(TheNPC, hook_character_Motion)>0);
      Result[c].Animation := SmartGetFieldInt(TheNPC, hook_character_Animation);
      Result[c].Height := iabs(SmartGetFieldInt(TheNPC, hook_character_GetHeight));
      Result[c].HPRatio := SmartGetFieldInt(TheNPC, hook_character_HPRatio) * 100 / $FF;
      Result[c].Fighting := (SmartGetFieldInt(TheNPC, hook_character_LoopCycleStatus) >
                              SmartGetFieldInt(0, hook_static_LoopCycle));
      Result[c].Orientation := Round(FixD(180 + (SmartGetFieldInt(TheNPC, hook_character_Orientation)* 45) / 2048));
      Result[c].Level := SmartGetFieldInt(TheNPCDef, hook_npcdef_GetLevel);
      Result[c].Interacting := SmartGetFieldInt(TheNPC, hook_character_GetInteracting);
      Inc(c);
    end;
  finally
    SmartFreeObject(TheNPCNode);
    SmartFreeObject(TheNPC);
  end;
  SetLength(Result, c);
end;

{*******************************************************************************
function FindNPC(theVar: Variant; var NPC: TNPC): Boolean;
By: lordsaturn
Description: If the NPC is found according to theVar, the NPC is placed in the
NPC variable. Results true if found; false otherwise.
*******************************************************************************}
function FindNPC(theVar: Variant; var NPC: TNPC): Boolean;
begin
  NPC := GetNPC(theVar);
  Result := NPC.ID > -1;
end;

{*******************************************************************************
function ValidNPC(theVar: Variant): Boolean;
By: lordsaturn
Description: Results true if the npc is found
*******************************************************************************}
function ValidNPC(theVar: Variant): Boolean;
var
  NPC: TNPC;
begin
  Result := FindNPC(theVar, NPC);
end;

{*******************************************************************************
procedure DumpNPCs(NPCs: TNPCArray);
By: Drags111
Description: Prints out the array of NPCs. Mainly for debugging purposes.
*******************************************************************************}
procedure DumpNPCs(NPCs: TNPCArray);
var
  i, Hi: integer;
begin
  Hi := High(NPCs);
  for i := 0 to Hi do
  begin
    Writeln('NPC: '+NPCs[i].Name);
    Writeln('    '+'Index: '+ ToStr(NPCs[i].Index));
    Writeln('    '+'ID: '+ToStr(NPCs[i].ID));
    Writeln('    '+'Actions: '+ ToStr(NPCs[i].Actions));
    Writeln('    '+'Tile: '+ ToStr(NPCs[i].Tile));
    Writeln('    '+'Animation: '+ ToStr(NPCs[i].Animation));
    Writeln('    '+'Height: '+ ToStr(NPCs[i].Height));
    Writeln('    '+'Fighting: '+ ToStr(NPCs[i].Fighting));
    Writeln('    '+'IsMoving: '+ ToStr(NPCs[i].Moving));
    Writeln('    '+'HPRatio: '+ ToStr(NPCs[i].HPRatio));
    Writeln('    '+'Level: '+ ToStr(NPCs[i].Level));
    Writeln('    '+'Orientation: '+ ToStr(NPCs[i].Orientation));
    Writeln('    '+'Interacting: '+ ToStr(NPCs[i].Interacting));
  end;
end;

{*******************************************************************************
function GetPlayers: array of TPlayer;
By: Widget edited by lordsaturn and drags111
Description: Returns all the players on the minimap
*******************************************************************************}
function GetPlayers: array of TPlayer;
var
  i, IndexPos, Count, Player, theName, L: integer;
begin
  Count := SmartGetFieldInt(0, hook_static_PlayerCount);
  SetArrayLength(result, Count);
  if Count < 1 then Exit;
  for i := 0 to Count-1 do
  try
    IndexPos := SmartGetFieldArrayInt(0, hook_static_PlayerIndexArray, i);
    Player := SmartGetFieldArrayObject(0, hook_static_GetPlayers, IndexPos);
    theName := SmartGetFieldObject(Player, hook_player_GetName);
    Result[L].Index := IndexPos;
    Result[L].Name := GetJavaString(theName, 255);
    Result[L].Tile.X := (SmartGetFieldInt(0, hook_static_BaseX) + (SmartGetFieldInt(Player, hook_animable_PixelX) / 512));
    Result[L].Tile.Y := (SmartGetFieldInt(0, hook_static_BaseY) + (SmartGetFieldInt(Player, hook_animable_PixelY) / 512));
    Result[L].Height := iabs(SmartGetFieldInt(Player, hook_character_GetHeight));
    Result[L].Animation := SmartGetFieldInt(Player, hook_character_Animation);
    Result[L].Moving := (SmartGetFieldInt(Player, hook_character_Motion)>0);
    Result[L].HPRatio := SmartGetFieldInt(Player, hook_character_HPRatio) * 100 / $FF;
    Result[L].Level := SmartGetFieldInt(Player, hook_player_GetLevel);
    Result[L].Orientation := Round(FixD(180 + (SmartGetFieldInt(Player, hook_character_Orientation)* 45) / 2048));
    Result[L].Interacting := SmartGetFieldInt(Player, hook_character_GetInteracting);
    Inc(L);
  finally
    SmartFreeObject(Player);
    SmartFreeObject(theName);
  end;
  SetArrayLength(Result, L);
end;

{*******************************************************************************
function SortPlayers(Players: TPlayerArray): TPlayerArray;
By: lordsaturn
Description: Sorts players by distance from you.
*******************************************************************************}
function SortPlayers(Players: TPlayerArray): TPlayerArray;
var
  i,i2, H: integer;
  tpa: TPointArray;
begin
  H := High(Players);
  if H < 0 then Exit;
  SetArrayLength(TPA, H+1);
  SetArrayLength(Result, H+1);
  for i := 0 to H do
    TPA[i] := Players[i].Tile;
  SortTPAFrom(TPA, GetMyPos);
  for i := 0 to H do
    for i2 := 0 to H do
      if (TPA[i].x=Players[i2].Tile.x) and (TPA[i].y=Players[i2].Tile.y) then
        Result[i] := Players[i2];
end;

{*******************************************************************************
function GetPlayersBy(TheVar: Variant): TPlayerArray;
By: Drags111
Description: Returns all the players by the variant. (Name or Index);
*******************************************************************************}
function GetPlayersBy(TheVar: Variant): TPlayerArray;
var
  vType, i, resCounter, Hi: Integer;
  Players: TPlayerArray;
  b: boolean;
begin
  Players := SortPlayers(GetPlayers);
  SetLength(Result, Length(Players));
  vType := VarType(TheVar);
  if (vType = varString) then
    TheVar := LowerCase(Trim(TheVar));
  Hi := High(Players);
  for i := Hi downto 0 do
  begin
    case vType of
      varInteger: B := Players[i].Index = TheVar;
      varString: B := (Pos(TheVar, LowerCase(Trim(Players[i].Name))) > 0);
      else Exit;
    end;
    if not B then
      Continue;
    Result[resCounter] := Players[i];
    inc(resCounter);
  end;

  SetLength(Result, resCounter);
end;

{*******************************************************************************
function GetPlayer(theVar: Variant):TPlayer;
By: Drags111
Description: Gets the closest player that matches the argument
*******************************************************************************}
function GetPlayer(theVar: Variant):TPlayer;
var
  Players: TPlayerArray;
  i, vType, Hi: Integer;
  B: Boolean;
begin
  Result := NULL_PLAYER;
  vType := VarType(TheVar);
  if (vType = varString) then
    TheVar := LowerCase(TheVar);
  Players := SortPlayers(GetPlayers);
  Hi := High(Players);
  for i := Hi downto 0 do
  begin
    case (vType) of
      varInteger: B := Players[i].Index = TheVar;
      varString: B := (Pos(TheVar, LowerCase(Players[i].Name)) > 0);
      else Continue;
    end;
    if (B) then
    begin
      Result := Players[i];
      Exit;
    end;
  end;
end;

{*******************************************************************************
function GetMe: TMe;
By: Widget, lordsaturn, Drags111
Description: Returns you
*******************************************************************************}
function GetMe: TMe; // Sounds funny =P
var
  Player, theName, pdef, i: integer;
begin
  try
    Player := SmartGetFieldObject(0, hook_static_MyPlayer);
    pdef := SmartGetFieldObject(Player, hook_player_PlayerDef);
    theName := SmartGetFieldObject(Player, hook_player_GetName);
    Result.Name := GetJavaString(theName, 255);
    Result.Tile.X := (SmartGetFieldInt(0, hook_static_BaseX) + (SmartGetFieldInt(Player, hook_animable_PixelX) / 512));
    Result.Tile.Y := (SmartGetFieldInt(0, hook_static_BaseY) + (SmartGetFieldInt(Player, hook_animable_PixelY) / 512));
    Result.Height := iabs(SmartGetFieldInt(Player, hook_character_GetHeight)) / 4;
    Result.Animation := SmartGetFieldInt(Player, hook_character_Animation);
    Result.Speed := SmartGetFieldInt(Player, hook_character_Motion);
    Result.HPRatio := SmartGetFieldInt(Player, hook_character_HPRatio) * 100 / $FF;
    Result.Level := SmartGetFieldInt(Player, hook_player_GetLevel);
    Result.InFight := (SmartGetFieldInt(0,hook_static_LoopCycle) < SmartGetFieldInt(Player,hook_character_LoopCycleStatus));
    Result.Orientation := Round(FixD(180 + (SmartGetFieldInt(Player, hook_character_Orientation)* 45) / 2048));
    Result.Interacting := SmartGetFieldInt(0, hook_character_GetInteracting);
    for i := 0 to 24 do
    begin
      Result.Experience[i] := SmartGetFieldArrayInt(0, hook_static_GetSkillExperiences, i);
      Result.Levels[i] := SmartGetFieldArrayInt(0, hook_static_GetSkillLevels, i);
    end;
  finally
    SmartFreeObject(theName);
    SmartFreeObject(Player);
    SmartFreeObject(pdef);
  end;
end;

{*******************************************************************************
function InteractingWithMe(NPC: TNPC): Boolean;
By: Drags111
Description: Checks if the NPC is currently interacting with your character.
*******************************************************************************}
function InteractingWithMe(NPC: TNPC): Boolean;
var
  Me: TMe;
  Player: TPlayer;
  PIdx: integer;
begin
  NPC := GetNPC(NPC.ID);
  Me := GetMe;
  PIdx := (NPC.Interacting - 32768);
  Player := GetPlayer(PIdx);
  Result := (Player.Name = Me.Name);
end;

